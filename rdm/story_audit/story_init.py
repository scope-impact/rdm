"""
Initialize requirements directory structure with templates.

Usage:
    rdm story init [--template infrastructure|application] [--output path]
"""

from __future__ import annotations

import sys
from pathlib import Path

from rdm.story_audit.schema import SCHEMA_VERSION


# =============================================================================
# TEMPLATE DEFINITIONS
# =============================================================================

INDEX_TEMPLATE = """\
# Requirements Index
# Schema Version: {schema_version}
# Generated by: rdm story init

project:
  name: "{project_name}"
  description: "{project_description}"
  scope: "{scope}"

# Phases organize features into logical development stages
phases:
  phase_1:
    description: "Initial implementation"
    features:
      - FT-001

# NOTE: Epic and Feature definitions should live in their respective directories:
#   - epics/EP-XXX.yaml
#   - features/FT-XXX.yaml
#
# The _index.yaml file should contain project metadata and phase organization.
# Avoid duplicating epic/feature definitions here to prevent ID conflicts.
"""

EPIC_TEMPLATE = """\
# Epic Definition
# Schema Version: {schema_version}

id: {epic_id}
title: "{epic_title}"
status: proposed

# List feature IDs that belong to this epic (references only, not full definitions)
features:
  - FT-001

# Optional fields
# phases: [phase_1, phase_2]
# note: Additional context about this epic
"""

FEATURE_TEMPLATE_INFRASTRUCTURE = """\
# Feature Definition - Infrastructure
# Schema Version: {schema_version}

id: {feature_id}
title: "{feature_title}"
epic_id: EP-001
phase: phase_1
priority: high
status: proposed

description: |
  Problem: [Describe the infrastructure challenge]

  Solution: [Describe the technical approach]

business_value: |
  [Explain why this infrastructure is needed]

user_stories:
  - id: {story_id_1}
    as_a: developer
    i_want: have a reliable deployment pipeline
    so_that: code changes can be deployed safely and consistently
    acceptance_criteria:
      - "AC-001: Pipeline runs on every commit to main branch"
      - "AC-002: Failed deployments automatically roll back"
      - "AC-003: Deployment logs are accessible for debugging"
    priority: high
    story_quality: core

  - id: {story_id_2}
    as_a: operations engineer
    i_want: monitor system health in real-time
    so_that: issues can be identified and resolved quickly
    acceptance_criteria:
      - "AC-001: Dashboards show key system metrics"
      - "AC-002: Alerts trigger when thresholds are exceeded"
    priority: medium
    story_quality: acceptable

definition_of_done:
  - Code reviewed and approved
  - Unit tests pass (>80% coverage)
  - Integration tests pass
  - Documentation updated
  - Security review completed

labels:
  - infrastructure
  - devops
"""

FEATURE_TEMPLATE_APPLICATION = """\
# Feature Definition - Application
# Schema Version: {schema_version}

id: {feature_id}
title: "{feature_title}"
epic_id: EP-001
phase: phase_1
priority: high
status: proposed

description: |
  Problem: [Describe the user problem or need]

  Solution: [Describe the application feature]

business_value: |
  [Explain the business benefit of this feature]

user_stories:
  - id: {story_id_1}
    as_a: user
    i_want: [perform some action]
    so_that: [achieve some benefit]
    acceptance_criteria:
      - "AC-001: [First acceptance criterion]"
      - "AC-002: [Second acceptance criterion]"
      - "AC-003: [Third acceptance criterion]"
    priority: high
    story_quality: core

  - id: {story_id_2}
    as_a: administrator
    i_want: [manage some aspect]
    so_that: [maintain system integrity]
    acceptance_criteria:
      - "AC-001: [First acceptance criterion]"
      - "AC-002: [Second acceptance criterion]"
    priority: medium
    story_quality: acceptable

definition_of_done:
  - Code reviewed and approved
  - Unit tests pass (>80% coverage)
  - Integration tests pass
  - UI/UX review completed
  - Accessibility requirements met
  - Documentation updated

labels:
  - application
  - user-facing
"""

RISK_TEMPLATE = """\
# Risk Register
# Schema Version: {schema_version}

id: RSK-001
title: "{risk_title}"
description: |
  [Detailed description of the risk]

category: "{category}"  # e.g., Spoofing, Tampering, Repudiation, Information Disclosure, DoS, Elevation
severity: medium        # critical, high, medium, low
probability: medium     # critical, high, medium, low
risk_level: medium      # Calculated: severity x probability
status: identified      # identified, mitigated, accepted, transferred

controls:
  - id: RC-001
    description: "[How this risk is mitigated]"
    implemented_by:
      - US-001
    verification: "[How to verify the control is effective]"
    status: proposed

residual_risk: low  # Risk level after controls are implemented
"""


# =============================================================================
# SCAFFOLD FUNCTIONS
# =============================================================================


def create_directory_structure(output_dir: Path, template: str) -> dict[str, str]:
    """Create the requirements directory structure.

    Returns:
        Dictionary of created file paths to their content
    """
    files_created: dict[str, str] = {}

    # Create directories
    (output_dir / "epics").mkdir(parents=True, exist_ok=True)
    (output_dir / "features").mkdir(parents=True, exist_ok=True)
    (output_dir / "risks").mkdir(parents=True, exist_ok=True)

    # Determine template content
    if template == "infrastructure":
        project_name = "Infrastructure Project"
        project_description = "Infrastructure and DevOps requirements"
        scope = "Infrastructure, CI/CD, monitoring, deployment"
        epic_title = "Platform Infrastructure"
        feature_title = "CI/CD Pipeline Setup"
        feature_template = FEATURE_TEMPLATE_INFRASTRUCTURE
        risk_title = "Infrastructure Security"
        risk_category = "Information Disclosure"
    else:  # application
        project_name = "Application Project"
        project_description = "Application feature requirements"
        scope = "User-facing features and functionality"
        epic_title = "Core Application Features"
        feature_title = "User Authentication"
        feature_template = FEATURE_TEMPLATE_APPLICATION
        risk_title = "Unauthorized Access"
        risk_category = "Spoofing"

    # Create _index.yaml
    index_content = INDEX_TEMPLATE.format(
        schema_version=SCHEMA_VERSION,
        project_name=project_name,
        project_description=project_description,
        scope=scope,
    )
    index_path = output_dir / "_index.yaml"
    files_created[str(index_path)] = index_content

    # Create example epic
    epic_content = EPIC_TEMPLATE.format(
        schema_version=SCHEMA_VERSION,
        epic_id="EP-001",
        epic_title=epic_title,
    )
    epic_path = output_dir / "epics" / "EP-001-example.yaml"
    files_created[str(epic_path)] = epic_content

    # Create example feature
    feature_content = feature_template.format(
        schema_version=SCHEMA_VERSION,
        feature_id="FT-001",
        feature_title=feature_title,
        story_id_1="US-001",
        story_id_2="US-002",
    )
    feature_path = output_dir / "features" / "FT-001-example.yaml"
    files_created[str(feature_path)] = feature_content

    # Create example risk
    risk_content = RISK_TEMPLATE.format(
        schema_version=SCHEMA_VERSION,
        risk_title=risk_title,
        category=risk_category,
    )
    risk_path = output_dir / "risks" / "RSK-001-example.yaml"
    files_created[str(risk_path)] = risk_content

    return files_created


def write_files(files: dict[str, str], dry_run: bool = False) -> list[str]:
    """Write files to disk.

    Args:
        files: Dictionary of file paths to content
        dry_run: If True, don't actually write files

    Returns:
        List of file paths that were (or would be) created
    """
    created = []
    for file_path, content in files.items():
        path = Path(file_path)
        if not dry_run:
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(content, encoding="utf-8")
        created.append(file_path)
    return created


# =============================================================================
# CLI ENTRY POINT
# =============================================================================


def story_init_command(
    output: Path | None = None,
    template: str = "application",
    dry_run: bool = False,
    force: bool = False,
) -> int:
    """Run story init command.

    Args:
        output: Output directory (default: ./requirements)
        template: Template type (infrastructure|application)
        dry_run: If True, show what would be created without creating
        force: If True, overwrite existing files

    Returns:
        0 on success, 1 on error
    """
    output_dir = output or Path("requirements")

    # Check if directory exists and has content
    if output_dir.exists() and any(output_dir.iterdir()):
        if not force:
            print(f"Error: Directory '{output_dir}' already exists and is not empty.")
            print("Use --force to overwrite existing files.")
            return 1
        if not dry_run:
            print(f"Warning: Overwriting existing files in '{output_dir}'")

    # Validate template
    if template not in ("infrastructure", "application"):
        print(f"Error: Unknown template '{template}'")
        print("Available templates: infrastructure, application")
        return 1

    # Create structure
    print(f"Initializing requirements structure with '{template}' template...")
    print(f"Output directory: {output_dir.resolve()}")
    print(f"Schema version: {SCHEMA_VERSION}")
    print()

    files = create_directory_structure(output_dir, template)

    if dry_run:
        print("Dry run - would create the following files:")
        for file_path in sorted(files.keys()):
            print(f"  {file_path}")
        print()
        print("Run without --dry-run to create these files.")
    else:
        created = write_files(files)
        print("Created files:")
        for file_path in sorted(created):
            print(f"  {file_path}")

    print()
    print("Directory structure:")
    print(f"  {output_dir}/")
    print("  ├── _index.yaml      # Project metadata")
    print("  ├── epics/")
    print("  │   └── EP-001-example.yaml")
    print("  ├── features/")
    print("  │   └── FT-001-example.yaml")
    print("  └── risks/")
    print("      └── RSK-001-example.yaml")
    print()
    print("Next steps:")
    print("  1. Edit _index.yaml with your project details")
    print("  2. Rename and customize the example files")
    print("  3. Run 'rdm story validate' to check your changes")
    print("  4. Run 'rdm story schema' to see full field documentation")

    return 0


def main() -> None:
    """CLI entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Initialize requirements directory structure"
    )
    parser.add_argument(
        "--output", "-o",
        type=Path,
        default=Path("requirements"),
        help="Output directory (default: ./requirements)",
    )
    parser.add_argument(
        "--template", "-t",
        choices=["infrastructure", "application"],
        default="application",
        help="Template type (default: application)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be created without creating",
    )
    parser.add_argument(
        "--force", "-f",
        action="store_true",
        help="Overwrite existing files",
    )
    args = parser.parse_args()

    sys.exit(story_init_command(
        output=args.output,
        template=args.template,
        dry_run=args.dry_run,
        force=args.force,
    ))


if __name__ == "__main__":
    main()
